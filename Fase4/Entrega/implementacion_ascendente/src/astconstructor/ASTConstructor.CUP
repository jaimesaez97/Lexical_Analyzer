package astconstructor;

import java_cup.runtime.*;
import lex.TinyLexicalAnalyzer;
import lex.LexicalUnit;
import err.TinyErrorMgmt;
import ast.*;

scan with {: return getScanner().next_token(); :};
action code {:
	private ASTiny as = new ASTiny();
:};
parser code{:
	private TinyErrorMgmt error;
	public void syntax_error(Symbol lexicalUnit){
		error.syntaxError((LexicalUnit) lexicalUnit);
	}
:};
init with{:
	error = new TinyErrorMgmt();
	TinyLexicalAnalyzer lex = (TinyLexicalAnalyzer)getScanner();
	lex.setErrorMgmt(error);
:};

terminal 	String  INT, REAL, BOOL, IDEN, END, TRUE, FALSE,
					EQUAL, PLUS, MINUS, MULT, DIV, AND, OR, NOT, 
					MAYOR, MINOR, MAYOREQUAL, MINOREQUAL, EQUIV, 
					NONEQUIV, NEG, OPPAR, CLPAR, SEMICOLON, NUMREAL,
					NUMINT;

non terminal S;
non terminal Ds Ds, D;
non terminal T T;
non terminal Is Is, I;
non terminal E E0, E1, E2, E3, E4, E5;

	S ::= Ds: aDeDs END Is: aDeIs
		{: RESULT=as.decIns(aDeDs, aDeIs); :};
	Ds::= D: aDeD
		{: RESULT=as.dSimple(aDeD.id(), aDeD.tipoT()); :};
	Ds::= Ds: aDeDs SEMICOLON D:aDeD
		{: RESULT=as.dCompuesta(aDeDs, aDeD.id(), aDeD.tipoT()); :};
	D ::= T: aDeT IDEN: lexDeIden
		{: RESULT=as.dSimple(lexDeIden, aDeT); :};
	T ::= INT
		{: RESULT=as.tInt(); :};
	T ::= REAL
		{: RESULT=as.tReal(); :};
	T ::= BOOL
		{: RESULT=as.tBool(); :};
	Is ::= I: aDeI
		{: RESULT=as.iSimple(aDeI.id(), aDeI.exp()); :};
	Is ::= Is: aDeIs SEMICOLON I:aDeI
		{: RESULT=as.iCompuesta(aDeIs, aDeI.id(), aDeI.exp()); :};
	I ::= IDEN: lexDeIden EQUAL E0: aDeE
		{: RESULT=as.iSimple(lexDeIden, aDeE); :};
	E0 ::= E0: aDeE0 PLUS E1: aDeE1
		{: RESULT= as.plus(aDeE0, aDeE1); :};
	E0 ::= E0: aDeE0 MINUS E1: aDeE1
		{: RESULT= as.subtraction(aDeE0, aDeE1); :};
	E0 ::= E1: aDeE1
		{: RESULT=aDeE1; :};
	E1 ::= E2: aDeE2 AND E1: aDeE1
		{: RESULT=as.and(aDeE2, aDeE1); :};
	E1 ::= E2: aDeE2a OR E2: aDeE2b
		{: RESULT=as.or(aDeE2a, aDeE2b); :};
	E1 ::= E2: aDeE2
		{: RESULT=aDeE2; :};
	E2 ::= E3: aDeE3a MINOR E3: aDeE3b
		{: RESULT=as.minor(aDeE3a, aDeE3b); :};
	E2 ::= E3: aDeE3a MAYOR E3: aDeE3b
		{: RESULT=as.mayor(aDeE3a, aDeE3b); :};
	E2 ::= E3: aDeE3a MINOREQUAL E3: aDeE3b
		{: RESULT=as.minorEqual(aDeE3a, aDeE3b); :};
	E2 ::= E3: aDeE3a MAYOREQUAL E3: aDeE3b
		{: RESULT=as.mayorEqual(aDeE3a, aDeE3b); :};
	E2 ::= E3: aDeE3a EQUIV E3: aDeE3b
		{: RESULT=as.equiv(aDeE3a, aDeE3b); :};
	E2 ::= E3: aDeE3a NONEQUIV E3: aDeE3b
		{: RESULT=as.nonEquiv(aDeE3a, aDeE3b); :};
	E2 ::= E3: aDeE3
		{: RESULT=aDeE3; :};
	E3 ::= E3: aDeE3 MULT E4: aDeE4
		{: RESULT=as.mult(aDeE3, aDeE4); :};
	E3 ::= E3: aDeE3 DIV E4: aDeE4
		{: RESULT=as.div(aDeE3, aDeE4); :};
	E3 ::= E4: aDeE4
		{: RESULT=aDeE4; :};
	E4 ::= NEG E4: aDeE4
		{: RESULT=as.neg(aDeE4); :};
	E4 ::= NOT E5: aDeE5
		{: RESULT=as.not(aDeE5); :};
	E4 ::= E5: aDeE5
		{: RESULT=aDeE5; :};
	E5 ::= OPPAR E0: aDeE0 CLPAR
		{: RESULT=aDeE0; :};
	E5 ::= IDEN: lexDeIden
		{: RESULT=as.id(lexDeIden); :};
	E5 ::= NUMREAL: lexDeNum
		{: RESULT=as.numReal(lexDeNum); :};
	E5 ::= NUMINT: lexDeNum
		{: RESULT=as.numInt(lexDeNum); :};
	E5 ::= TRUE
		{: RESULT=as.eTrue(); :};
	E5 ::= FALSE
		{: RESULT=as.eFalse(); :};

